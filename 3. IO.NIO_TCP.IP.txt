
NIO/IO:

	TCP/IP: 套接字连接
		OSI七层模型:
			应用层: Http协议, 解释通讯内容
			表示层:
			会话层:
			传输层: TCP/UDP, 基于端口的点对点通讯协议.
			网络层: IP地址区分电脑所在的子网.
			数据链路层: 子网内部通过mac地址寻找到对方
			物理层: 把电脑连接起来的设备
		TCP/IP模型:
                	应用层: DNS, Ping
                	传输层: TCP, UDP
                	网络层: IP
                	数据链路层: DataLink
                TCP三次握手和四次挥手: https://blog.csdn.net/qzcsu/article/details/72861891
                        三次握手:
				1. TCP服务器进程处于监听状态
				2. 客户端发送连接请求[报文SYN=1]
				3. 服务器同意链接, 发送确认报文[SYN=1,ACK=1]
				4. 客户端接收到确认后, 发送[ACK=1]  - 防止两步连接服务器不能确认.
                        四次挥手:
				1. 客户端发送释放连接请求[FIN=1], 进入FIN-WAIT-1状态
				2. 服务器收到释放请求, 响应确认[ACK=1]
				3. 客户端收到确认响应.
				4. 服务器发送完最后的数据后, 发送释放报文[FIN=1]
				5. 客户端收到释放请求, 发送[ACK=1], 进入TIME_WAIT状态,等待2msl
				6. 服务器收到后立马CLOSE
                        TIME_WAIT状态: TIME_WAIT期间, 系统不会建立与此连接相同的连接(Sip:Sport and Dip:Dport).
                                1. 实现可靠的四次挥手断开连接: 假设没有TIME_WAIT状态, client收到对端的FIN分节发送ACK分节之后就变为了CLOSED状态,
                                        这个ACK分节可能会丢失, 一旦超时服务器端就会重新发送FIN给client, 但此时的client已经CLOSED,
                                        只能回应RST分节, 会造成server的异常关闭
                                2. 清除前一个连接的旧报文影响: TIME_WAIT的时间是2MSL, 在这期间是禁止建立相同四元组的连接-设计-思想
                        关闭连接为什么四次挥手:
                                客户端释放连接请求表示不再发送数据, 但是还能接收数据, 而服务器也未必全部数据都发送给对方
                        连接过程中客户端故障:
                                TCP保活计时器, 如2小时没有收到client数据, 就会发送探测报文, 10次后关闭连接.
                TCP 如何保证传输可靠性?
                        1. 应用数据被分割成 TCP 认为最适合发送的数据块。
                        2. TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
                        3. 确认响应ACK
                        4. 超时重发.
                        5. 接收时对包进行校验: TCP将保持它首部和数据的检验和.
                        6. 丢弃重复数据
		TCP拥塞控制:
			https://www.cnblogs.com/wuquaaa/p/11953352.html
		TCP滑动窗口:
			固定窗口: 发送方每发送一个数据接收方就要给发送方一个ACK对这个数据进行确认, 确认后再发送
			如果发送方收到接收方的窗口大小为0的TCP数据报，那么发送方将停止发送数据，
			1. 第一次发送数据这个时候的窗口大小是根据链路带宽的大小来决定的。
                        2. 假设这时候的窗口是3.这个时候接收方收到数据以后会对数据进行确认告诉发送方我下次希望收到的数据是多少。
				首先发送1,2,3三个数据包, 等待响应.
				如果发送3, 那么发送方就接着从3这个数据包开始发送.

                HTTP:
                        Http请求格式:
                                请求行: 请求方法, URL, 协议版本
                                请求头: key-value的附加信息
                                请求正文:
                        HTTP长连接、短连接: 本质上是TCP连接
                                连接默认长连接
                                请求头里面keep-alive去掉就变成短连接
                        各种协议与HTTP协议之间的关系
                                DNS解析用到UDP协议.
                                搜索对方用到IP协议
                                传输用到TCP协议.
		HTTP2.0:
                在浏览器中输入url地址 ->> 显示主页的过程:
			1. DNS解析: 通过DNS缓存/DNS服务器解析域名, 拿到IP地址
				用子网掩码对两个IP做与运算, 看是不是一个子网的
                        2. TCP连接:
                        3. 发送HTTP请求
                        4. 服务器处理请求并返回HTTP报文
                        5. 浏览器解析渲染页面
                        6. 连接结束
                        7. 在数据链路层传输的时候如果数据包很大会被切割多个数据包, 每个包里包含序号,
                                服务器接收到所有包后拼起来.

                Https的原理:
                        证书验证: (非对称加密)
				1. 浏览器发起 HTTPS 请求
                                2. 服务端返回 HTTPS 证书(包含公钥)
                                3. 客户端验证证书是否合法，如果不合法则提示告警
                        数据传输: (对称加密)
				1. 当证书验证合法后，在本地生成随机数
                                2. 通过公钥加密随机数，并把加密后的随机数传输到服务端
                                3. 服务端通过私钥对随机数进行解密
                                4. 服务端通过客户端传入的随机数构造对称加密算法, 对返回结果内容进行加密后传输
			数据传输是用对称加密:
				非对称加密的效率低.
				需要两对公私钥, 而只有服务端保存了私钥
			为什么要CA认证机构颁发证书:
				HTTP 协议被因为传输过程容易被勾线监听, 伪造服务器而不安全, DNS劫持.
				证书校验被拦截后中间人没有私钥解不开.
				CA证书有合法性:
					颁发机构信息, 公钥, 公司信息, 域名...
				校验过程:
					1. 验证域名、有效期等信息是否正确
					2. 判断证书来源是否合法
					3. CA服务器进行校验证书是否被篡改

                        为什么用了 HTTPS 就是安全的？
                                HTTPS 保证了传输安全, 非对称加密啊和对称加密
                                但只能保证通信被监听的安全.
                https和http区别:
                        1. 是否需要证书校验
                        2. 是否加密. http明文传输.
                        3. 端口不通, 连接方式不同
                        4. HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议
	        多路复用的几种方式以及区别:
	                概念: 同时监控多个IO事件，当哪个IO事件准备就绪就执行哪个IO事件
	                1.select ----->windows linux unix（苹果内核）: 单个进程能够监视的文件描述符的数量存在最大限制，通常是1024。
	                        由于select采用轮询的方式扫描文件描述符，文件描述符数量越多，性能越差；
	                        内核/用户空间内存拷贝，select需要大量的句柄数据结构，产生巨大开销；
	                        select返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生事件；
	                2.poll ----->linux unix: 使用链表保存文件描述符，没有了文件描述符的限制
	                3.epoll ----->linux unix: epoll使用了一个文件描述符管理了多个文件描述符. 线程安全.

		CSRF漏洞: (Cross Site Request Forgery，跨站请求伪造)
			 1. 二次验证，进行重要敏感操作时，要求用户进行二次验证。
                         2. 验证码，进行重要敏感操作时，加入验证码。
                         3. 验证 HTTP 的 Referer 字段。
                         4. 请求地址中添加 Token 并验证。
                         5. HTTP 头中自定义属性并验证。

	UPD:
		TCP、UDP 协议的区别:
			1. 面向连接/无连接
			2. TCP可靠传输, ACK确认无错不重复顺序到达, UDP最大努力交付不保证可靠.
			3. UDP效率高, 一对多多对多等, TCP点对点.
			4. TCP数据安全资源多, UDP快.
		TCP, UDP应用:
                        1. FTP：定义了文件传输协议，数据使用20端口，控制使用21端口。
                        2. Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。
                        3. SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。
                        4. POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。
                        5. HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。
			1. DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。
			2. SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。
			3. TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口69上使用UDP服务。
			4. DHCP(Dynamic Host Configuration Protocol)：动态主机配置协议是一个局域网的网络协议， 主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作***管理的手段。



	IP和mac地址区别: https://blog.csdn.net/guoweimelon/article/details/50858597
		IP地址是互联网协议地址
		MAC地址是硬件地址, 用来定义网络设备的位置。全球唯一性

        进程与线程的区别是什么: 通讯方式是什么?
                进程: 进程是表示资源分配的基本单位，又是调度运行的基本单位.
                        管道(pipe), 信号(signal), 消息队列(message queue), 信号量(semaphore), 共享内存(shared memory), 套接字(socket)
                线程: 线程是进程中执行运算的最小单位，亦即执行处理机调度的基本单位。
                        消息消息队列, 事件, 信号量(semaphore). 等待通知, lock/condition

        Java对象序列化: ObjectOutputStream, ObjectInputStream.
        Serialization底层如何实现: ObjectOutputStream.



	Netty:



网络和操作系统: 复习一些常见的网上都能搜到的字节考题就行，不用太深入 todo











