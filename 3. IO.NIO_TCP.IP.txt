
NIO/IO:

	TCP/IP: 套接字连接
		TCP/IP模型:
                	应用层: DNS, Ping
                	传输层: TCP, UDP
                	网际层: IP
                	网络接口层: DataLink
                TCP三次握手和四次挥手: https://blog.csdn.net/qzcsu/article/details/72861891
                        三次握手:
				1. TCP服务器进程处于监听状态
				2. 客户端发送连接请求[报文SYN=1]
				3. 服务器同意链接, 发送确认报文[SYN=1,ACK=1]
				4. 客户端接收到确认后, 发送[ACK=1]  - 防止两步连接服务器不能确认.
                        四次挥手:
				1. 客户端发送释放连接请求[FIN=1], 进入FIN-WAIT-1状态
				2. 服务器收到释放请求, 响应确认[ACK=1]
				3. 客户端收到确认响应.
				4. 服务器发送完最后的数据后, 发送释放报文[FIN=1]
				5. 客户端收到释放请求, 发送[ACK=1], 进入TIME_WAIT状态,等待2msl
				6. 服务器收到后立马CLOSE
                        TIME_WAIT状态: TIME_WAIT期间, 系统不会建立与此连接相同的连接(Sip:Sport and Dip:Dport).
                                1. 实现可靠的四次挥手断开连接: 假设没有TIME_WAIT状态, client收到对端的FIN分节发送ACK分节之后就变为了CLOSED状态,
                                        这个ACK分节可能会丢失, 一旦超时服务器端就会重新发送FIN给client, 但此时的client已经CLOSED,
                                        只能回应RST分节, 会造成server的异常关闭
                                2. 清除前一个连接的旧报文影响: TIME_WAIT的时间是2MSL, 在这期间是禁止建立相同四元组的连接-设计-思想
                        关闭连接为什么四次挥手:
                                客户端释放连接请求表示不再发送数据, 但是还能接收数据, 而服务器也未必全部数据都发送给对方
                        连接过程中客户端故障:
                                TCP保活计时器, 如2小时没有收到client数据, 就会发送探测报文, 10次后关闭连接.
                TCP 如何保证传输可靠性?
                        1. 应用数据被分割成 TCP 认为最适合发送的数据块。
                        2. TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
                        3. 确认响应ACK
                        4. 超时重发.
                        5. 接收时对包进行校验： TCP将保持它首部和数据的检验和.
                        6. 丢弃重复数据

                HTTP:
                        Http请求格式:
                                请求行: 请求方法, URL, 协议版本
                                请求头: key-value的附加信息
                                请求正文:
                        HTTP长连接、短连接: 本质上是TCP连接
                                连接默认长连接
                                请求头里面keep-alive去掉就变成短连接
                        各种协议与HTTP协议之间的关系
                                DNS解析用到UDP协议.
                                搜索对方用到IP协议
                                传输用到TCP协议.
		HTTP2.0:
                在浏览器中输入url地址 ->> 显示主页的过程:
			1. DNS解析
                        2. TCP连接
                        3. 发送HTTP请求
                        4. 服务器处理请求并返回HTTP报文
                        5. 浏览器解析渲染页面
                        6. 连接结束

                Https的原理:
                        证书验证: (非对称加密)
				1. 浏览器发起 HTTPS 请求
                                2. 服务端返回 HTTPS 证书(包含公钥)
                                3. 客户端验证证书是否合法，如果不合法则提示告警
                        数据传输: (对称加密)
				1. 当证书验证合法后，在本地生成随机数
                                2. 通过公钥加密随机数，并把加密后的随机数传输到服务端
                                3. 服务端通过私钥对随机数进行解密
                                4. 服务端通过客户端传入的随机数构造对称加密算法, 对返回结果内容进行加密后传输
			数据传输是用对称加密:
				非对称加密的效率低.
				需要两对公私钥, 而只有服务端保存了私钥
			为什么要CA认证机构颁发证书:
				HTTP 协议被因为传输过程容易被勾线监听, 伪造服务器而不安全, DNS劫持.
				证书校验被拦截后中间人没有私钥解不开.
				CA证书有合法性:
					颁发机构信息, 公钥, 公司信息, 域名...
				校验过程:
					1. 验证域名、有效期等信息是否正确
					2. 判断证书来源是否合法
					3. CA服务器进行校验证书是否被篡改

                        为什么用了 HTTPS 就是安全的？
                                HTTPS 保证了传输安全, 非对称加密啊和对称加密
                                但只能保证通信被监听的安全.
                https和http区别:
                        1. 是否需要证书校验
                        2. 是否加密. http明文传输.
                        3. 端口不通, 连接方式不同
                        4. HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议
	        多路复用的几种方式以及区别:
	                概念: 同时监控多个IO事件，当哪个IO事件准备就绪就执行哪个IO事件
	                1.select ----->windows linux unix（苹果内核）: 单个进程能够监视的文件描述符的数量存在最大限制，通常是1024。
	                        由于select采用轮询的方式扫描文件描述符，文件描述符数量越多，性能越差；
	                        内核/用户空间内存拷贝，select需要大量的句柄数据结构，产生巨大开销；
	                        select返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生事件；
	                2.poll ----->linux unix: 使用链表保存文件描述符，没有了文件描述符的限制
	                3.epoll ----->linux unix: epoll使用了一个文件描述符管理了多个文件描述符. 线程安全.

	UPD:
		TCP、UDP 协议的区别: 面向连接/无连接

	IP和mac地址区别: https://blog.csdn.net/guoweimelon/article/details/50858597
		IP地址是互联网协议地址
		MAC地址是硬件地址, 用来定义网络设备的位置。全球唯一性

        进程与线程的区别是什么: 通讯方式是什么?
                进程: 进程是表示资源分配的基本单位，又是调度运行的基本单位.
                        管道(pipe), 信号(signal), 消息队列(message queue), 信号量(semaphore), 共享内存(shared memory), 套接字(socket)
                线程: 线程是进程中执行运算的最小单位，亦即执行处理机调度的基本单位。
                        消息消息队列, 事件, 信号量(semaphore). 等待通知, lock/condition
		有没有用过其他安全传输手段?

        Java对象序列化: ObjectOutputStream, ObjectInputStream.
        Serialization底层如何实现: ObjectOutputStream.



	Netty:












