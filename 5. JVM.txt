JVM:
	Synchronized底层实现: 
		javap 命令查看字节码信息看.
		使用方法:	修饰实例方法: 锁当前对象, ACC_SYNCHRONIZED 
				修饰静态方法: 锁当前类对象, 
				修饰代码块: 自行指定锁对象, monitorenter&monitorexit
		1.6后优化:
			原来效率低: 重量级锁, 监视器锁（monitor）依赖操作系统的MutexLock来实现的, Java线程映射到操作系统的原生线程. 
				线程之间切换要从用户态转内核态.
			1. 偏向锁: 没有多线程竞争的前提下，减少传统重量级锁使用操作系统互斥量产生的性能消耗。会偏向于第一个获得它的线程，
				如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步！对于锁竞争比较激烈的场合，偏向锁就失效升级成轻量级锁.
			2. 轻量级锁: 在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，
				因为使用轻量级锁时，不需要申请互斥量。轻量级锁的加锁和解锁都用到了CAS操作, 使用 CAS 操作避免了使用互斥操作的开销。
				如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作, 很快膨胀为重量级锁.
			3. 重量级锁: 
			4. 自旋锁和自适应自旋: 轻量级锁失败后，虚拟机为了避免线程在操作系统层面挂起，会用自旋锁优化手段。
				自旋去拿锁. 自适应自旋就是自旋的时间不固定了，是前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定.
			5. 锁消除: 检测到那些共享数据不可能存在竞争，那么就执行锁消除
			6. 锁粗化: 同一对象反复加锁&解锁会粗化
		锁升级过程: 线程访问同步代码块 
			-[是什么锁]:
				偏向锁: -[对象头里记录的是否是当前线程]:	是: 获得偏向锁执行同步代码块
									否: CAS操作替换threadID. -[替换成功吗]	是: 获得偏向锁执行同步代码块
														否: 开始撤销偏向锁(竞争出现才释放锁), 持有偏向锁的线程到达安全点并暂停.	-[持有偏向锁的线程是否完成同步代码块]	是: 原持有的线程释放偏向锁, 接着开始抢偏向锁咯
																										否: 升级为轻量级锁!.原偏向锁线程栈内分配锁记录, 拷贝对象头的markworld到锁记录. 原来的偏向锁线程拿到轻量级锁接着从安全点执行. 抢的线程就[抢轻量级锁]
				轻量级锁: [抢轻量级锁], 在当前线程中分配锁记录, 拷贝markWrold到锁记录, CAS操作把对象markWorld指向本线程,-[是否成功?]	成功:	获得轻量级锁, 执行同步代码块. 执行完后解锁. -[CAS对比对象markWorkd是否与栈内一致, 是否指向本线程]	CAS一致: 释放锁成功.
																													CAS不一致: 说明升级锁了, 释放锁, 唤醒被挂起的线程, 让他们新竞争锁.
																	失败:	自旋修改哦, -[自选修改是否成功]	成功: 获得轻量级锁...
																						失败: 升级重量级锁, 修改markWrold, 挂起当前线程. 等着轻量级锁线程执行完, 叫起自己.
				重量级锁: mutex挂起当前线程, 等着被叫起来.
		和ReentrantLock的区别:	1. 都是可重入锁
					2. synchronized依赖于jvm, reentrantLock依赖于API.
					3. ReentrantLock增加了等待可中断, 公平锁, 选择性通知.
		Synchronized和Lock哪个更好:
	编译:
		编译器:
			1. 前端编译器: JavaC编译器: 1.解析与填充符号表, 2.插入式注解处理器的注解处理. 3.分析与字节码生成.
			2. 运行时编译器: JIT: 编译热点代码
				1. HotSpotJVM为什么使用解释器与编译器并存架构: 启动快+运行快.
				2. HotSpotJVM要实现两个不同的JIT? 编译器编译,优化的规模和耗时, 划分不同的编译层次. C1进行简单可靠优化, C2进行激进优化, 监控性能.
				3. 程序何时使用解释器编译, 什么时候用JIT?
				4. 哪些程序代码会被编译成本地代码, 如何编译本地代码?
				5. 如何从外部观察JIT的编译过程和结果
		运行时优化:
			1. 数组边界清楚检查
			2. 方法内联
			3. 解释器与编译器配合
			4. 公共表达式消除
			5. 逃逸分析, 栈上分配.
	Java对象内存布局: https://www.jianshu.com/p/91e398d5d17c java内存模型
		对象头:	markWorld: 一系列的标记位，比如轻量级锁的标记位，偏向锁标记位等等。在32位系统占4字节，在64位系统中占8字节；
			classPointer: 指向对象对应的Class对象的内存地址, 在32位系统占4字节，在64位系统中占8字节
			length(arrayObject): 4个字节
		实例数据: 包括了对象的所有成员变量，其大小由各个成员变量的大小决定
		补齐
	Java 对象的创建过程: 
		加载: 根据全限定名获取类的二进制字节流, 读取字节流到方法区的运行时数据结构, 在内存中生成class对象.
		验证: 文件格式校验, 源数据校验, 字节码校验, 符号引用校验.
		准备: 正式在方法区中为类变量(static)分配内存并设置类变量初始值(默认零值), 初始化阶段才会赋值. 如果加上final就会设置成应该是的值. 
			设置对象头.
		解析: 虚拟机将常量池内的符号引用替换为直接引用的过程, 类/接口, 字段, 类方法, 接口方法, 方法类型, 方法句柄, 调用限定符等器类引用.
		初始化: 执行类中定义的类构造器 <clinit>()方法, 自带锁线程安全, 多线程可能会引起死锁. new, reflect, 父类, main类等才会初始化.
			建立虚方法表, 为动态分派做准备
	类初始化顺序:
		1. 静态属性: static
		2. 静态方法块: static{}
		3. 普通属性:
		4. 普通方法块
		5. 构造函数:
		6. 普通方法
	类加载器, 双亲委派模型:
		启动类加载器: C++实现, 加载javahome/lib迷路下的jar包. 
		扩展类加载器: 加载javahome/lib/ext目录下的jar包. 父类加载器为null，代表BootstrapClassLoader 
		应用程序类加载器: 加载classpath目录下的jar包
		双亲委派模型: 在类加载的时候，首先判断当前类是否被加载过, 把该请求委派该父类加载器的 loadClass() 处理.
			不是通过继承来体现的，是由“优先级”来决定.java.lang.ClassLoader 的 loadClass()有先检查是否被加载过, 先用父类加载器去加载.
		双亲委派好处: 避免类的重复加载,  保证Java的核心API不被篡改, 保证系统中只有一个Object类. 
		自定义类加载器: 重写loadClass().
			除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自java.lang.ClassLoader. 自定义自己的类加载器, 继承 ClassLoader。
	类文件结构: 
		1. 魔数: u4, java
		2. class文件版本: 两个u2, 代表小大版本.
		3. 常量池: u2标识常量池数量, cp_info常量池表. 表的开始u1标志类型
		4. 访问标志: u2, 访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。
		5. 当前类索引,父类索引与接口索引集合: 当前类, 父类, 接口, 多个接口[]
		6. 字段表集合: u2字段个数, file_info[].
		7. 方法表: 
		8. 属性表: u2属性数, attribute_info[], Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息
	Java内存区域: 
		方法区(1.6及之前): 包含运行时常量池.
		元空间: 线程共享, 类信息、常量、静态变量、即时编译器编译后的代码等数据。JVM规范把方法区描述为堆的一个逻辑部分.
		堆: 线程共享, 存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。垃圾收集器管理的主要区域.
			新生代: 
			老年代: 
			永久代: (1.7)
			元空间: (1.8),代替方法区, 也代替了永久代.
			运行时常量池: (1.8): 存放编译期生成的各种字面量和符号引用
		虚拟机栈: 线程私有, 描述Java方法执行的内存模型, 方法调用的数据通过栈传递的。局部变量表、操作数栈、动态链接、方法出口信息。
			StackOverFlowError 和 OutOfMemoryError, return返回/throw返回
			方法的符号引用在解析阶段有一部分会变成动态链接. 在运行时候才会变成直接引用.
		本地方法栈: 和虚拟机栈非常相似, 为虚拟机使用到的 Native 方法服务.
		程序计数器: 线程私有, 当前线程所执行的字节码的行号指示器。分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。不会OutOfMemoryError.
		永久代 (PermGen) 替换为元空间(MetaSpace): 永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存.
			元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 MaxPermSize控制.
		直接内存: 直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域, 因为NIO可以直接使用 Native 函数库直接分配堆外内存.
	Java内存分配
		java内存分配的两种方式:
			指针碰撞: 适合堆内存规整没有内存碎片, 把用过的内存整合到一边,没有用过的在另一边中间有分界值指针. GC: serial,parNew.
			空闲列表: 适合内存不规整的情况, 维护列表, 记录可用内存块, 每次分配找足够大的内存来分配对象实例. GC: CMS
		内存分配并发问题: 
			CAS+失败重试：虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。
			TLAB: 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，
				首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配
		分配策略: 
			1. TLAB(Thread Local Allocation Buffer)线程本地分配缓冲区
			2. Eden区中分配, tlab分不了.
			3. Humongous区分配, eden分不了.
			对象优先在eden区分配
			大对象直接进入老年代
			长期存过的对象进入老年代:
			动态对象年龄判定: 虚拟机不是永远要求对象年龄必须达到了某个值才能进入老年代, Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，
				年龄大于或等于该年龄的对象就可以直接进入老年代，无需达到要求的年龄。
	对象的访问定位的两种方式:
		句柄: Java堆中划分出一块句柄池，reference中存储对象的句柄地址, 而句柄中包含了对象实例数据与类型数据各自的具体地址信息.
		直接指针: reference 中存储的直接就是对象的地址。[只要使用 new 方法，便需要创建新的对象。]
	String类和常量池: 
		String str1 = "abcd";//先检查字符串常量池中有没有"abcd"，如果字符串常量池中没有，则创建一个，然后str1 指向字符串常量池中的对象;
		String str2 = new String("abcd");//堆中创建一个新的对象, 也会先检查池中是否有, 没有就创建.
		直接使用双引号声明出来的 String 对象会直接存储在常量池中;
		String.intern(), 如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用
		String str3 = "str" + "ing";//常量池中的对象;
		String str4 = str1 + str2; //在堆上创建的新的对象;
	8种基本类型的包装类和常量池: 
		整形: 包装类默认创建了数值[-128，127] 的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。
		Boolean也实现了常量池技术
		Float,Double: 没有实现常量池技术
	如何判断对象是否死亡: 
		引用计数法: 为对象添加引用计数器, 为引用的数量. 实现简单高效, 但是无法解决循环引用的问题.
		可达性分析算法: 通过一系列的称为 “GC Roots” 的对象作为起点开始向下搜索，走过的路径称为引用链, 当一个对象到GCRoots没有任何引用链证明此对象是不可用的。
			GCRoot有: 虚拟机栈(栈帧中的本地变量表)中的引用的对象, 类静态属性引用的对象, 方法区钟常量引用的对象, native方法引用的对象
		不可达的对象并非“非死不可”: 它们暂时处于“缓刑阶段”, 要经历两次标记过程.
			1. 此对象是否有必要执行 finalize 方法。
			2. 对象将会被放在一个队列中进行第二次标记, 这个对象与引用链上的任何一个对象建立关联，就不会回收。
	虚引用与软引用和弱引用的区别、使用软引用能带来的好处: 
		JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种. 之前只是reference类型数据存储的就是引用
		1. 强引用(StrongReference): 最普遍的引用, 垃圾回收器绝不会回收它, JVM宁愿抛出 OutOfMemoryError 错误.
		2. 软引用(SoftReference): 可有可无的, 内存空间不足了，就会回收这些对象的内存, 可用来实现内存敏感的高速缓存。
		3. 弱引用(WeakReference): 与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。不管当前内存空间足够与否，都会回收它的内存。不过GC线程优先级低, 不一定会发现.
			弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。
		4. 虚引用(PhantomReference): 形同虚设, 对象仅持有虚引用，那么它就和没有任何引用一样.主要用来跟踪对象被垃圾回收的活动.
			虚引用"必须"和引用队列（ReferenceQueue）联合使用, GC准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。
			程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。
			不会决定对象的生命周期.
	如何判断一个常量是废弃常量: 
		假如在常量池中存在字符串 "abc", 如果没有String对象引用, 就是废弃常量，如果这时发生GC"abc"就会被系统清理出常量池。
	如何判断一个类是无用的类: 同时满足三个条件, 才有可能会被回收.
		1. 该类所有的实例都已经被回收
		2. 加载该类的 ClassLoader 已经被回收
		3. 该类对应的 java.lang.Class 对象没有在任何地方被引用, 无法被反射.
	GC: 
		线程运行到safePoint开始GC: safePoint是线程相对稳定的点.
			抢先式中断: 先中断所有线程, 把没有到安全点的线程放走到下个安全点停止
			主动式中断: GC通知线程, 该中断了啊, 等到所有线程中断后开始GC.
		垃圾收集有哪些算法，各自的特点？
			1. 标记-清除算法: 
				1. 分为“标记”和“清除”阶段
				2. 最基础的收集算法, 后续算法都是为了弥补这个不足:
				3. 效率问题: 低
				4. 空间问题: 标记清除后会产生大量不连续的碎片
			2. 复制算法: 解决效率问题
				1. 将内存分为大小相同的两块, 一块的内存用完, 就将还存活的对象复制到另一块，再把第一块一次清理掉
				2. 空间问题: 只用了最多一半.
			3. 标记-整理算法: 
				1. 标记过程仍然与“标记-清除”算法一样, 让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。
			4. 分代收集算法: 
				1. 当前虚拟机的垃圾收集都采用分代收集算法, 根据对象存活周期的不同将内存分为几块, 根据各个年代的特点选择合适的垃圾收集算法.
				2. HotSpot为什么要分为新生代和老年代: 就是因为分代收集可以根据各年代对象的特点选择适合的收集器.
		常见的垃圾回收器: 垃圾收集器就是内存回收算法的具体实现.根据具体应用场景选择适合自己的垃圾收集器
			1. 串行(Serial)收集器: 最基本、最悠久的垃圾收集器. 单线程收集器, Stop The World 直到收集结束.
				新生代采用复制算法, 老年代采用标记-清理算法.
				没有线程交互的开销, 简单而高效（与其他收集器的单线程相比）
			2. ParNew 收集器: Serial 收集器的多线程版本
				新生代采用复制算法, 老年代采用标记-清理算法.
				它可以与CMS配合工作.
			3. Parallel Scavenge 收集器: 是使用复制算法的多线程收集器, 几乎和ParNew都一样
				1. 可以设置使用Parallel收集器+老年代串行/并行.
				2. 关注点是吞吐量(高效率的利用 CPU), CMS等垃圾收集器的关注点更多的是用户线程的停顿时间(提高用户体验)。
				3. 新生代采用复制算法，老年代采用标记-整理算法。
			4. Serial Old 收集器: Serial 收集器的老年代版本.作为 CMS 收集器的后备方案.
			5. Parallel Old 收集器: Parallel Scavenge 收集器的老年代版本。
			6. CMS 收集器: 并发收集器.Concurrent Mark Sweep
				1. "标记-清除"算法. 
					初始标记(stopTheWorld)：初始标记仅仅只是标记一下GC Roots能直接关联到的对象
					并发标记：进行GC Roots Tracing
					重新标记：修正并发标记期间因用户程序继续运作而导致标记产生表动的那一部分对象的标记记录，停顿时间一般会比初始标记阶段稍长，但比并发标记短。
					并发清除：
				2. 并发收集、低停顿, 对 CPU 资源敏感；无法处理浮动垃圾；标记-清除有大量空间碎片产生
			7. G1收集器: 面向服务器的垃圾收集器, 满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.
				1. 初始标记, 并发标记, 最终标记, 筛选回收; 可预测的停顿 
				2. G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。
				3. G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region.
				4. 并行于并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短stop-The-World
		CMS,G1收集器: https://blog.csdn.net/PAcee1/article/details/86527804 
		Minor Gc 和 Full GC 有什么不同呢: 
			新生代GC(MinorGC):指发生新生代的的垃圾收集动作, MinorGC非常频繁, 回收速度一般也比较快.
			老年代GC(MajorGC/FullGC):指发生在老年代的GC, 出现了MajorGC经常会伴随MinorGC(并非绝对),MajorGC的速度一般会比MinorGC的慢10倍以上
		减少GC开销的编码技巧: 减少短期对象的分配
			1. 避免隐式String字符串
			2. 计划好List的容量.
			3. 分散对象创建或删除的时间
			4. 少使用静态对象变量
	JVM哪些参数: https://segmentfault.com/a/1190000010603813
		1. 堆内存相关: 
			1. 显式指定初始化堆内存大小CXms和-Xmx
			2. 显式新生代内存(Young Ceneration): -XX:NewSize, -XX:MaxNewSize
				将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC.
			3. 显示指定永久代/元空间的大小: (1.8之前) -XX:PermSize=N -XX:MaxPermSize=N
				(1.8): -XX:MetaspaceSize=N, -XX:MaxMetaspaceSize=N
		2. 垃圾收集相关: 
			1. 垃圾收集器: JVM四种GC: 串行, 并行, GMS, G1.
				-XX:+UseSerialGC, -XX:+UseParallelGC, -XX:+USeParNewGC, -XX:+UseG1GC
			2. GC记录:
				-XX:+UseGCLogFileRotation, -XX:NumberOfGCLogFiles=< number of log files > ,
				-XX:GCLogFileSize=< file size >[ unit ], -Xloggc:/path/to/gc.log
				OOM后做heapDump: 
				-XX:+HeapDumpOnOutOfMemoryError  -XX:HeapDumpPath=c:\jakarta-tomcat\webapps
			3. GC调优: https://tech.meituan.com/2017/12/29/jvm-optimize.html  https://www.choupangxia.com/2019/11/11/interview-jvm-gc-08/
				1. 目的: 将转移到老年代的对象数量降低到最小； 减少 GC 的执行时间。
				2. 将新对象预留在新生代，调节新生代大小，最大限度降低新对象直接进入老年代的情况。
				3. 大对象进入老年代, 大对象在新生代会出现空间不足, -XX:PretenureSizeThreshold 可以设置直接进入老年代的对象大小。
				4. 设置稳定的堆大小
				5. 不需要优化: MinorGC 执行时间不到50ms； Minor GC 执行不频繁，约10秒一次； Full GC 执行时间不到1s； Full GC 执行频率不算频繁，不低于10分钟1次。
		3. 实际:
		        -Xms3g -Xmx3g JVM堆内存
                        -XX:PermSize=256M -XX:MaxPermSize=1024m 非堆内存
                        -XX:NewSize=2048m -XX:MaxNewSize=2048m
                        -XX:SurvivorRatio=10 from 、to分别占Young Generation的空间的1/10，Eden占8/10;
                            NewRatio默认2, 新生代:老年1:2
			调优:    1. -XX:NewSize, -XX:MaxNewSize 显示设置为
				2. SurvivorRatio调整为10, 增加from的大小
		4. OOM事件:
                        1. Quartz定时任务内存泄漏: The web application [/project] appears to have started a thread named [SchedulerFactoryBean-Worker-1] but has faild to stop it
                                原因: 系统在关闭时没有给Quartz时间来停止它所创建的定时任务，导致线程未被停止系统便已经关闭了。
                                解决: 配置QuartzContextListener实现ServletContextListener，并在ContextDestroyed时执行SchedulerFactoryBean的shutdown方法
                        2. 线程未关闭异常:
                                原因: httpAsyncClient客户端在请求失败的情况下，httpclient.close()此处会导致主线程阻塞，
                                        经源码发现close方法内部，在线程连接池关闭以后,
                                        httpAsyncClient对应线程还处于运行之中，一直阻塞在epollWait
                        3. 创建超大数组:
                                原因: 定时任务项目跑数据, OOM
                                解决: JVM调整新生代大小-Xmx, 并增加编码规则.
	JVM 自带查看工具: 
		JPS: 类似于ps命令, 查看所有java进程启动类, 传入参数和 Java 虚拟机参数等信息；
		jstat: (JVM Statistics Monitoring Tool), 收集 HotSpot 虚拟机各方面的运行数据, 查看GC同济.
		jinfo (Configuration Info for Java) : Configuration Info forJava,显示虚拟机配置信息;
		jmap (Memory Map for Java) :生成堆转储快照;
		jhat (JVM Heap Dump Browser ) : 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果;
		jstack (Stack Trace for Java):生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。
	JDK可视化分析工具:
		JConsole:Java 监视与管理控制台: 监视本地及远程服务器的 java 进程的内存使用情况。
		Visual VM:多合一故障处理工具: 
	排查线上oom: 
	线上服务器cpu飙高:  找到对应的线程, 看线程的堆栈信息.
		1. top命令，查看CPU占用情况, 定位进程的PID. 
		2. top -Hp PID 查看进程的各个线程ID的CPU占用
		3. jstack PID |grep -A 200 ID 查看栈信息(ID为16进制)
	JVM调优: 减少GC的频率和Full GC的次数
	JVM性能调优都做了什么:
		1. 堆内存设置: 初始化内存和最大内存尽量保持一致，避免内存不够用继续扩充内存。 
			1.老年代空间不足会导致fullGC
			2.永久代/元空间空间不足
			3. System.gc()不要显示调用
			1. 新生代不要太小, 会频繁gc
			2. 新生代不要太大, gc时间太长, 1/3比较好
			3. survivor不要设置太大太小.
		2. 收集器设置: 对不同年龄代用合适的收集器
		3. 监控JVM: 
			1. GCLog
				1. gc时间又没有变长
				2. fullGc频率.
			2. JPS,jstack.jconsole查看jvm状态.
	防火墙session过多: 
	MESI: 
	Semaphore: 可以控制进入数量的synchronized


JVM内存模型(JMM): 内存模型规范, 屏蔽了硬件/系统差异.
	1. 每个cpu都有自己的高速缓存, 通过缓存一致性协议操作主内存
	2. 内存屏障(硬件层): loadBarrier(读屏障)和storeBarrier(写屏障).
		为了解决不同cpu运行的线程使用的同一个变量的缓存值不同问题
		指令前插入读屏障, 可以让高速缓存中的数据失效, 强制从主内存取.
		内存屏障还可以组织两侧指令重排序.
		volatile变量就是加入了内存屏障. 保持可见性.
	3. JMM规范内容: 五大内存区域.....
		对象的内存布局...
		对象的定位: 句柄池, 直接指针.
	JMM的happens before原则:
	程序顺序原则:
	锁原则:
	线程中断原则:
	传递性原则:











线程运行时候代码在哪里, 同步方法内容在哪里?

JVM，垃圾回收机制，内存划分



新生代分为几个区？使用什么算法进行垃圾回收？为什么使用这个算法？
java线程如何启动？

JVM中堆是如何管理的，JVM的内存回收机制，介绍一下

classLoader 机制





怎么样知道java存中是哪一些模块消耗内存比较多；

应用服务器的参数调整。

synchronized 关键字的底层原理

synchronized 关键字底层做了哪些优化-锁升级过程

说说 synchronized 关键字和 volatile 关键字的区别
内存模型以及分区，需要详细到每个区放什么。

GC 收集器有哪些？CMS 收集器与 G1 收集器的特点。

Minor GC 与 Full GC 分别在什么时候发生？

堆里面的分区：Eden，survival （from+ to），老年代，各自的特点。

简述 java 垃圾回收机制?

java 中垃圾收集的方法有哪些?

类加载器双亲委派模型机制？什么是类加载器，类加载器有哪些?

简述 java 内存分配与回收策率以及 Minor GC 和Major GC


